#!/usr/bin/env python
from CutFinder.configs import ConfigRef
from CutFinder.plots import Plotter
from CutFinder.readers import ConfigReader

import multiprocessing
import os
import json

import numpy as np
import typer
from typing_extensions import Annotated
from rich.console import Console
from rich import print as pprint
import ROOT

ROOT.gInterpreter.Declare('#include "include/functions.cpp"')

app = typer.Typer(
    pretty_exceptions_show_locals=False, rich_markup_mode="rich", add_completion=False
)
console = Console(record=True)


@app.command()
def main(
    path: Annotated[
        str, typer.Option("-c", "--config", help="Path to the config file.")
    ],
    output: Annotated[
        str, typer.Option("-o", "--output", help="Path to the output folder.")
    ],
    ncpus: int = typer.Option(
        multiprocessing.cpu_count(),
        "-j",
        "--ncpus",
        help="Number of CPUs to use.",
    ),
):
    if ncpus > 1:
        ROOT.EnableImplicitMT(ncpus)

    config_reader = ConfigReader(path)
    glob = config_reader.glob
    objs = config_reader.objs
    refs = config_reader.refs
    for ref in refs:
        for obj in objs:
            if obj.refs is not None:
                if ref not in obj.refs:
                    continue
            if ((obj.scaling is not None and ref.scaling is None) or
                (obj.scaling is None and ref.scaling is not None)):
                raise ValueError(f"You are comparing Offline and Online pT between obj {obj.name} and ref {ref.name}. Please provide scaling functions for both configurations or none.")
            # if already computed, compute does nothing
            ref.compute()
            obj.compute()
            cuts = glob.algo(ref, obj, glob, **glob.algo_kwargs)
            #inverse scale if scaling is applied
            if obj.scaling is not None:
                cut_bins = obj.inverse_scaling(np.array(glob.pt_bins))
            else:
                cut_bins = glob.pt_bins

            #compute rate with new cuts for full binning
            clone = obj.clone(ConfigRef, WP=[cut_bins, cuts])
            clone.compute()
            clone.makeRate(glob.pt_bins, glob.maxRate)

            #create record and save cuts
            obj.addToRecord(ref, "full", cut_bins, cuts, clone.rate)

            fitted_cut_bins, fitted_cuts, chi2 = glob.regressor(
                cut_bins,
                cuts,
                fitrange=glob.fitrange,
                **glob.regressor_kwargs,
            )
            fitted_clone = obj.clone(
                ConfigRef, WP=[fitted_cut_bins, fitted_cuts]
            )
            fitted_clone.compute()
            fitted_clone.makeRate(glob.pt_bins, glob.maxRate)

            #create record and save cuts
            obj.addToRecord(
                ref,
                "fitted",
                fitted_cut_bins,
                fitted_cuts,
                fitted_clone.rate,
                #chi2=chi2,
            )

    #prepare output folder
    os.makedirs(output, exist_ok=True)
    os.system(f"cp -f {path} {output}/{path.split('/')[-1]}")

    plotter = Plotter()
    for obj in objs:
        os.makedirs(f"{output}/{obj.name}", exist_ok=True)
        #copy index.php
        os.system(f"cp {os.path.join(os.path.dirname(__file__),"externals/index.php")} {output}/{obj.name}/index.php")

        #plots
        plotter.plot_rates(glob, obj, output=output)
        plotter.plot_cuts(obj, output=output)

        #add glob pt_bins to record and save records.json
        if isinstance(glob.pt_bins, np.ndarray):
            obj.records["pt_bins"] = glob.pt_bins.tolist()
        else:
            obj.records["pt_bins"] = glob.pt_bins
        with open(f"{output}/{obj.name}/records.json","w") as fp:
            json.dump(obj.records, fp, indent=4)
    #TODO remove at the end
    breakpoint()



if __name__ == "__main__":
    app()
