#!/usr/bin/env python
from CutFinder.readers import ConfigReader

import multiprocessing

import typer
from typing_extensions import Annotated
from rich.console import Console
from rich import print as pprint
import ROOT

ROOT.gInterpreter.Declare('#include "include/functions.cpp"')

app = typer.Typer(
    pretty_exceptions_show_locals=False, rich_markup_mode="rich", add_completion=False
)
console = Console(record=True)


@app.command()
def main(
    path: Annotated[
        str, typer.Option("-c", "--config", help="Path to the config file.")
    ],
    output: Annotated[
        str, typer.Option("-o", "--output", help="Path to the output folder.")
    ],
    ncpus: int = typer.Option(
        multiprocessing.cpu_count(),
        "-j",
        "--ncpus",
        help="Number of CPUs to use.",
    ),
):
    if ncpus > 1:
        ROOT.EnableImplicitMT(ncpus)

    config_reader = ConfigReader(path)
    glob = config_reader.glob
    objs = config_reader.objs
    refs = config_reader.refs
    for ref in refs:
        for obj in objs:
            if obj.refs is not None:
                if ref not in obj.refs:
                    continue
            ref.compute()  # if ref already computed, compute does nothing
            obj.compute()
            cuts = glob.algo(ref, obj, glob)
            breakpoint()

            ####DEBUG beteween obj:new_id and ref:custom (same samples but global score cut of 0)
            print("Cuts found:", cuts)
            from CutFinder.configs import ConfigRef

            new = obj.clone(ConfigRef, WP=[glob.pt_bins, cuts])
            new.compute()
            new.makeRate(glob.pt_bins, glob.maxRate)
            print(f"Original object rates: {ref.rate}")
            print(f"New object rates after applying cuts: {new.rate}")
            import matplotlib.pyplot as plt

            plt.figure()
            plt.plot(glob.pt_bins, ref.rate, label="Original object")
            plt.plot(glob.pt_bins, new.rate, label="New object after cuts")
            plt.xlabel("pT [GeV]")
            plt.ylabel("Rate [kHz]")
            plt.yscale("log")
            plt.legend()
            plt.show()
            breakpoint()
            #!NB in bin 1 i have the warning target rate higher than current rate. That's not true. Investigate. Line by line!!!

if __name__ == "__main__":
    app()
